#include <iostream>
#include <algorithm>
#include <math.h>
#include <tuple>
#include <vector>

using namespace std;

pair<int, int> arr[20002];
//tuple<pair<int, int>, pair<int, int>, int> t0[2];
tuple<int, int, int> t1[2];
tuple<int, int, int> t2[2];

vector<tuple<int, int, int>> res;

pair<int, int> p;

int n;
// 두 점 사이의 거리 : sqrt(pow(x1-x2) + pow(y1-y2),2);

int compare(pair<int, int> a, pair<int, int> b) {
	return a.second < b.second;
}

int res_compare(tuple<int, int,int > a, tuple<int,int, int> b) {
	return get<2>(a) < get<2>(b);
}

int closest(int st, int ed, int min_d) {
	sort(arr, arr + n, compare); // y축으로 재 정렬.

	for (int i = st; i < ed+1; i++) { // st=0 ed=4 ->. 0-> 1234 1->234 2->34 3->4 4->4 //i <= ed 할 경우 같은 값 비교함. 에러.
		for (int j = i + 1; j < ed+1; j++) {
			if (arr[j].second - arr[i].second > min_d) break; // y축 기준으로 정렬 되어있으므로 해당 i값의 j랑 비교 의미 x

			int temp = sqrt(pow(arr[i].first - arr[j].first, 2) + pow(arr[i].second - arr[j].second, 2));
			min_d = min(min_d, temp);
			if (min_d == temp) {
				res.push_back({ arr[i].first, arr[i].second, min_d });
				res.push_back({ arr[j].first, arr[j].second, min_d });
			}
		}

	}
	return min_d;
}

int func(int st,int ed) {
	int point = ed - st +1; // func (0, 2) // 0,1,2 --> plus +1
	
	if (point == 2) {
		int dist = sqrt(pow(arr[st].first - arr[ed].first, 2) + pow(arr[st].second - arr[ed].second, 2));
//		t0[0] = { arr[st],arr[st + 1],dist };
		t1[0] = {arr[st].first, arr[st].second , dist};
		t1[1] = { arr[st].first, arr[st].second, dist };
		return dist;
	}
	else if (point == 3) {
	int p1 = sqrt(pow(arr[st].first - arr[st+1].first, 2) + pow(arr[st].second - arr[st+1].second, 2)); // 첫번째 점 , 두번째 점 거리
	int p2 = sqrt(pow(arr[st].first - arr[st+2].first, 2) + pow(arr[st].second - arr[st+2].second, 2)); // 첫번째 점 , 세번째 점 거리
	int p3 = sqrt(pow(arr[st+1].first - arr[st+2].first, 2) + pow(arr[st+1].second - arr[st+2].second, 2)); // 두번째 점 , 세번째 점 거리
	if (min({p1,p2,p3}) == p1) {
		t2[0] = {arr[st].first, arr[st].second , p1};
		t2[1] = { arr[st+1].first, arr[st+1].second , p1 };
		return min({ p1, p2, p3 });
	}
	else if(min({p1,p2,p3}) == p2){
		t1[0] = {arr[st].first, arr[st].second , p2};
		t1[1] = { arr[st+2].first, arr[st+2].second , p2 };
		return min({ p1, p2, p3 });
	}
	else if (min({ p1,p2,p3 }) == p3) {
		t1[0] = {arr[st + 1].first, arr[st + 1].second , p3};
		t1[1] = { arr[st+2].first, arr[st+2].second , p3 };
		return min({ p1, p2, p3 });
	}
	//return min({ p1, p2, p3 }); // min({1,2,3})--> // o min({1,2},3)--> x
	}

	else {
		int mid = (st + ed)/2; // func(st, (st+ed)/2)로 설정 하면 무한 루프 빠짐.
		int min_st = func(st, mid); //ex 0,2
		int min_ed = func(mid + 1, ed); //ex 4,6
		int min_d = min(min_st, min_ed);
		if (min_d == min_st) {
			res.push_back({ get<0>(t1[0]), get<1>(t1[0]), min_d });
			res.push_back({ get<0>(t1[1]), get<1>(t1[1]), min_d });
		}
		else {
			res.push_back({ get<0>(t2[0]), get<1>(t2[0]), min_d });
			res.push_back({ get<0>(t2[1]), get<1>(t2[1]), min_d });
		}
		return closest(st,ed,min_d);
	}

}






int main() {
	cin >> n;

	for (int i = 0; i < n; i++) {
		cin >> arr[i].first >> arr[i].second;
	}
	//sort(arr, arr + n);
	//cout << "'''''''''''''''" << "\n";
	//for (int i = 0; i < n; i++) cout << arr[i].first << " " << arr[i].second << "\n";
	
	
	//sort(arr, arr + n, compare);

	func(0,n-1);
	sort(res.begin(), res.end(), res_compare);

	
	

//	cout << "'''''''''''''''" << "\n";
//	for (int i = 0; i < n; i++) cout << arr[i].first << " " << arr[i].second << "\n";

//	cout << "(" << get<0>(res[2]) << ", " << get<1>(res[2]) << ") " << "(" << get<0>(res[3]) << ", " << get<1>(res[3]) << ")";
	for (auto a : res) cout << get<0>(a) << " " << get<1>(a) << " " << get<2>(a) << "\n";
//	cout << "\n";
//	for (auto a : res) cout << get<2>(a) << " ";
	
}
