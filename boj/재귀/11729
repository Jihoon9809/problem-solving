#include <iostream>

using namespace std;

int func(int a, int b, int n) {
	if (n == 1) {
		cout << a << " " << b << "\n";
		return 1;
	}
	func(a, 6 - a - b, n - 1);
	cout << a << " " << b << "\n";
	func(6 - a - b, b, n - 1);
}

int main() {
	int n, res = 1;
	cin >> n;

	for (int i = 0; i < n; i++) {
		res *= 2;
	}
	cout << res - 1 << "\n";
	func(1, 3, n);
}



이 문제 또한 어려웠다. 이해할 수 없어 검색을 참고 했다.
재귀함수의 경우 절차식으로 풀경우 끝도없이 빠지기 때문에 귀납법을 통해 풀어야한다.
왜 정확히 동작하는지 하나하나 신경쓰다 보니 문제를 풀지 못했다.

해당 문제는 하노이의 탑으로 맨밑의 가장큰 수를 n으로 보았을때 n 이외의 수를 모두 옮겼고 n을 옮길 차례일 때 출력문을 해야하므로
탈출구 (break condition)을 n==1 일때 출력으로 하였다.

이후 문제를 구현하기 위해 3가지 경우를 따졌다.
3의 크기인 탑이 있을때, 3,2는 2로 옮긴 경우 1-->2 // a=1, b=3 이므로 1,2,3 총합은 6이다. 그러므로 6-a-b는 2가 된다. 이경우 func(1,2,n-1)을 작성한다.
이후 1을 3으로 옮긴다 1-->3 // 1--> 으로 옮길때 무조건 출력.
이후 나머지 2에 있는 것을 3으로 옮긴다 2-->3 // 2-->3으로 가는 것 또한 첫번째 조건문과 동일하다.

절차는 어려워 설명하기 힘들지만 n이 가능하면 n-1도 가능하고 n+1도 가능하다 따라서 위의 코드를 작성했다.





